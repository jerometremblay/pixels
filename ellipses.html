<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ellipses</title>
    <link rel="stylesheet" href="pixels.css" />
  </head>
  <body>
    <header>
      <a href="index.html">← Back to Pixels Lab</a>
    </header>
    <div class="hud">
      <div class="hud-header">
        <div class="hud-title">Ellipses</div>
        <button class="hud-toggle" id="hudToggle" aria-label="Toggle controls">×</button>
      </div>
      <div id="hud">Ellipses grid ready.</div>
      <label>
        Size
        <input type="range" id="blockSize" min="8" max="48" step="0.25" value="14" />
      </label>
      <label>
        Width
        <input type="range" id="lineWidth" min="0.5" max="5" step="0.1" value="3" />
      </label>
      <label>
        X axis
        <input type="range" id="axisX" min="0.2" max="1" step="0.02" value="0.7" />
      </label>
      <label>
        Y axis
        <input type="range" id="axisY" min="0.2" max="1" step="0.02" value="0.7" />
      </label>
    </div>
    <svg class="grid" id="grid" aria-label="Pixel grid" role="img"></svg>

    <script src="pixels.js"></script>
    <script>
      const axisXInput = document.getElementById("axisX");
      const axisYInput = document.getElementById("axisY");

      const lineWidthInput = document.getElementById("lineWidth");
      const hud = document.querySelector(".hud");
      const hudToggle = document.getElementById("hudToggle");
      hudToggle.addEventListener("click", () => {
        hud.classList.toggle("collapsed");
        hudToggle.textContent = hud.classList.contains("collapsed") ? "☰" : "×";
      });
      const ellipseBounds = { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity };
      let highlightCount = 0;

      Pixels.initPixelGrid({
        blockSizeId: "blockSize",
        strokeWidthMultiplier: () => Number(lineWidthInput.value) || 3,
        onBuildStart: () => {
          ellipseBounds.minX = Infinity;
          ellipseBounds.maxX = -Infinity;
          ellipseBounds.minY = Infinity;
          ellipseBounds.maxY = -Infinity;
          highlightCount = 0;
        },
        hudText: (metrics) =>
          `Ellipse axes: ${Math.round(Number(axisXInput.value) * 100)}% × ${Math.round(
            Number(axisYInput.value) * 100
          )}%\nBlock: ${Math.round(metrics.blockSize)}px\nHighlighted: ${highlightCount}`,
        isHighlighted: ({ cx, cy, metrics }) => {
          const rx = metrics.radius * Number(axisXInput.value || 0.7);
          const ry = metrics.radius * Number(axisYInput.value || 0.7);
          const dx = cx - metrics.centerX;
          const dy = cy - metrics.centerY;
          const k = Math.hypot(dx / rx, dy / ry);
          const approxDist = Math.abs(k - 1) * Math.min(rx, ry);
          return approxDist <= metrics.strokeWidth / 2 + 1e-6;
        },
        onCell: ({ cx, cy, metrics, highlight }) => {
          if (!highlight) return;
          highlightCount += 1;
          const half = metrics.blockSize / 2;
          ellipseBounds.minX = Math.min(ellipseBounds.minX, cx - half);
          ellipseBounds.maxX = Math.max(ellipseBounds.maxX, cx + half);
          ellipseBounds.minY = Math.min(ellipseBounds.minY, cy - half);
          ellipseBounds.maxY = Math.max(ellipseBounds.maxY, cy + half);
        },
        drawOverlay: ({ grid, metrics, svgNS, settings }) => {
          const rx = metrics.radius * Number(axisXInput.value || 0.7);
          const ry = metrics.radius * Number(axisYInput.value || 0.7);
          const bounds =
            ellipseBounds.minX !== Infinity
              ? ellipseBounds
              : {
                  minX: metrics.centerX - rx - metrics.strokeWidth / 2,
                  maxX: metrics.centerX + rx + metrics.strokeWidth / 2,
                  minY: metrics.centerY - ry - metrics.strokeWidth / 2,
                  maxY: metrics.centerY + ry + metrics.strokeWidth / 2,
                };
          const guidePad = metrics.blockSize * 2;

          const guideLeft = document.createElementNS(svgNS, "line");
          guideLeft.setAttribute("x1", bounds.minX - guidePad);
          guideLeft.setAttribute("y1", bounds.minY);
          guideLeft.setAttribute("x2", bounds.minX - guidePad);
          guideLeft.setAttribute("y2", bounds.maxY);
          guideLeft.setAttribute("stroke", "#94a3b8");
          guideLeft.setAttribute("stroke-opacity", 0.35);
          guideLeft.setAttribute("stroke-width", Math.max(1, metrics.blockSize * 0.15));
          grid.appendChild(guideLeft);

          const guideTop = document.createElementNS(svgNS, "line");
          guideTop.setAttribute("x1", bounds.minX);
          guideTop.setAttribute("y1", bounds.minY - guidePad);
          guideTop.setAttribute("x2", bounds.maxX);
          guideTop.setAttribute("y2", bounds.minY - guidePad);
          guideTop.setAttribute("stroke", "#94a3b8");
          guideTop.setAttribute("stroke-opacity", 0.35);
          guideTop.setAttribute("stroke-width", Math.max(1, metrics.blockSize * 0.15));
          grid.appendChild(guideTop);

          const widthBlocks = Math.round((bounds.maxX - bounds.minX) / metrics.blockSize);
          const heightBlocks = Math.round((bounds.maxY - bounds.minY) / metrics.blockSize);
          const topLabel = document.createElementNS(svgNS, "text");
          topLabel.setAttribute("x", (bounds.minX + bounds.maxX) / 2);
          topLabel.setAttribute(
            "y",
            bounds.minY - guidePad - Math.max(6, metrics.blockSize * 0.4)
          );
          topLabel.setAttribute("text-anchor", "middle");
          topLabel.setAttribute("fill", "#cbd5f5");
          topLabel.setAttribute("font-size", Math.max(10, metrics.blockSize * 0.7));
          topLabel.textContent = `${widthBlocks} blocks`;
          grid.appendChild(topLabel);

          const leftLabel = document.createElementNS(svgNS, "text");
          leftLabel.setAttribute(
            "x",
            bounds.minX - guidePad - Math.max(6, metrics.blockSize * 0.4)
          );
          leftLabel.setAttribute("y", (bounds.minY + bounds.maxY) / 2);
          leftLabel.setAttribute("text-anchor", "middle");
          leftLabel.setAttribute("dominant-baseline", "middle");
          leftLabel.setAttribute("fill", "#cbd5f5");
          leftLabel.setAttribute("font-size", Math.max(10, metrics.blockSize * 0.7));
          leftLabel.textContent = `${heightBlocks} blocks`;
          leftLabel.setAttribute(
            "transform",
            `rotate(-90 ${bounds.minX - guidePad - Math.max(6, metrics.blockSize * 0.4)} ${
              (bounds.minY + bounds.maxY) / 2
            })`
          );
          grid.appendChild(leftLabel);

          const ellipse = document.createElementNS(svgNS, "ellipse");
          ellipse.setAttribute("cx", metrics.centerX);
          ellipse.setAttribute("cy", metrics.centerY);
          ellipse.setAttribute("rx", rx);
          ellipse.setAttribute("ry", ry);
          ellipse.setAttribute("fill", "none");
          ellipse.setAttribute("stroke", "#94a3b8");
          ellipse.setAttribute("stroke-opacity", settings.strokeOpacity);
          ellipse.setAttribute("stroke-width", metrics.strokeWidth);
          grid.appendChild(ellipse);

          const centerSize = metrics.blockSize * 0.7;
          const centerX = metrics.centerX;
          const centerY = metrics.centerY;
          const centerMark1 = document.createElementNS(svgNS, "line");
          centerMark1.setAttribute("x1", centerX - centerSize / 2);
          centerMark1.setAttribute("y1", centerY - centerSize / 2);
          centerMark1.setAttribute("x2", centerX + centerSize / 2);
          centerMark1.setAttribute("y2", centerY + centerSize / 2);
          centerMark1.setAttribute("stroke", "#e2e8f0");
          centerMark1.setAttribute("stroke-opacity", 0.8);
          centerMark1.setAttribute("stroke-width", Math.max(1, metrics.blockSize * 0.2));
          grid.appendChild(centerMark1);

          const centerMark2 = document.createElementNS(svgNS, "line");
          centerMark2.setAttribute("x1", centerX + centerSize / 2);
          centerMark2.setAttribute("y1", centerY - centerSize / 2);
          centerMark2.setAttribute("x2", centerX - centerSize / 2);
          centerMark2.setAttribute("y2", centerY + centerSize / 2);
          centerMark2.setAttribute("stroke", "#e2e8f0");
          centerMark2.setAttribute("stroke-opacity", 0.8);
          centerMark2.setAttribute("stroke-width", Math.max(1, metrics.blockSize * 0.2));
          grid.appendChild(centerMark2);
        },
      });

      axisXInput.addEventListener("input", () => window.dispatchEvent(new Event("resize")));
      axisYInput.addEventListener("input", () => window.dispatchEvent(new Event("resize")));
      lineWidthInput.addEventListener("input", () => window.dispatchEvent(new Event("resize")));
    </script>
  </body>
</html>
